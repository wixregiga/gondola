package orm

import (
	"bytes"
	"flag"
	"os"
	"reflect"
	"runtime"
	"strings"
	"testing"
	"time"

	"gondola/config"
	"gondola/log"
	"gondola/orm/driver"
)

// Interface for orm openers, so we can run each individual
// test with any available driver.
type opener interface {
	Open(testing.TB) (*Orm, interface{})
	Close(interface{})
	Name() string
}

var (
	drv     = flag.String("driver", "default", "Driver to use for running the driver-less tests")
	openers = make(map[string]opener)
)

func funcName(f interface{}) string {
	ptr := reflect.ValueOf(f).Pointer()
	rf := runtime.FuncForPC(ptr)
	if rf != nil {
		return rf.Name()
	}
	return ""
}

func testName(openerName string, f interface{}) string {
	return openerName + "-" + strings.TrimPrefix(funcName(f), "gondola/orm.")
}

func runTest(t *testing.T, f func(*testing.T, *Orm)) {
	o := openers[*drv]
	if o == nil {
		t.Fatalf("no driver named %s", *drv)
	}
	orm, data := o.Open(t)
	defer o.Close(data)
	defer orm.Close()
	t.Run(testName(o.Name(), f), func(t *testing.T) {
		f(t, orm)
	})
}

func runBenchmark(b *testing.B, f func(*testing.B, *Orm)) {
	o := openers[*drv]
	if o == nil {
		b.Fatalf("no driver named %s", *drv)
	}
	orm, data := o.Open(b)
	defer o.Close(data)
	defer orm.Close()
	f(b, orm)
}

type AutoIncrement struct {
	Id int64 `orm:",primary_key,auto_increment"`
	// Must have another field, otherwise there are
	// no fields to insert
	Value string
}

type BadAutoIncrement struct {
	Id string `orm:",primary_key,auto_increment"`
}

type Timestamp struct {
	Id        int64 `orm:",primary_key,auto_increment"`
	Timestamp time.Time
}

type Object struct {
	Id     int64 `orm:",primary_key,auto_increment"`
	Value  string
	loaded int `orm:"-"`
	saved  int `orm:"-"`
}

type Data struct {
	Id   int64 `orm:",primary_key,auto_increment"`
	Data []byte
}

func (o *Object) Load() {
	o.loaded++
}

func (o *Object) Save() {
	o.saved++
}

type Inner struct {
	A int `orm:",omitempty"`
	B int `orm:",omitempty"`
}

type Outer struct {
	Id    int64 `orm:",primary_key,auto_increment"`
	Key   string
	Inner *Inner
}

type Composite struct {
	Id    int
	Name  string `mysql:",max_length=255"`
	Value string
}

type EmptyDefaulter struct { // This type also tests value-less inserts
	Val1 string `orm:",default=Gondola,max_length=200"` // Set max_length since MySQL does not support defaults for TEXT
	Val2 int    `orm:",default=7"`
}

type PartialDefaulter struct {
	Val1 string
	Val2 string `orm:",default=Gondola"`
}

type Defaulter struct {
	Id   int64     `orm:",primary_key,auto_increment"`
	Val1 string    `orm:",default=Gondola"` // When using MySQL, this default is set by the ORM.
	Val2 time.Time `orm:",default=NoW()"`   // function names should be case insensitive
	Val3 time.Time `orm:",default=today()"`
}

type Timestamped struct {
	Id        int64 `orm:",primary_key,auto_increment"`
	Timestamp time.Time
}

func equalTimes(t1, t2 time.Time) bool {
	// Compare seconds, since some backends (like sqlite) loss subsecond precission
	return t1.Truncate(time.Second).Equal(t2.Truncate(time.Second))
}

func clearRegistry(o *Orm) {
	// Clear registry
	globalRegistry.names = make(map[string]nameRegistry)
	globalRegistry.types = make(map[string]typeRegistry)
	if o != nil {
		o.typeRegistry = globalRegistry.types[o.tags]
	}
}

func newOrm(t testing.TB, url string, logging bool) *Orm {
	clearRegistry(nil)
	o, err := New(config.MustParseURL(url))
	if err != nil {
		t.Fatal(err)
	}
	if logging {
		// Set logger
		o.SetLogger(log.Std)
		if testing.Verbose() && os.Getenv("ORM_TEST_DEBUG") != "" {
			log.SetLevel(log.LDebug)
		}
	} else {
		log.SetLevel(log.LInfo)
	}
	return o
}

func (o *Orm) mustRegister(t interface{}, opts *Options) *Table {
	tbl, err := o.Register(t, opts)
	if err != nil {
		panic(err)
	}
	return tbl
}

func (o *Orm) mustInitialize() {
	if err := o.Initialize(); err != nil {
		panic(err)
	}
}
func testAutoIncrement(t *testing.T, o *Orm) {
	if o.Driver().Capabilities()&driver.CAP_AUTO_ID == 0 {
		t.Log("skipping auto increment test")
		return
	}
	o.mustRegister((*AutoIncrement)(nil), nil)
	o.mustInitialize()
	obj := &AutoIncrement{}
	o.MustSave(obj)
	if o.Driver().Capabilities()&driver.CAP_AUTO_INCREMENT != 0 {
		if obj.Id != 1 {
			t.Errorf("Invalid autoincremented id %v, expected 1", obj.Id)
		}
	} else {
		if obj.Id == 0 {
			t.Error("Invalid autogenerated id zero, expected non zero")
		}
	}
}

func testBadAutoincrement(t *testing.T, o *Orm) {
	if o.Driver().Capabilities()&driver.CAP_AUTO_ID == 0 {
		t.Log("skipping bad auto increment test")
		return
	}
	_, err := o.Register((*BadAutoIncrement)(nil), nil)
	if err == nil {
		err = o.Initialize()
	}
	if err == nil {
		t.Error("expecing an error when using BadAutoIncrement")
	}
}

func testTime(t *testing.T, o *Orm) {
	o.mustRegister((*Timestamp)(nil), nil)
	o.mustInitialize()
	now := time.Now()
	t1 := &Timestamp{}
	o.MustSave(t1)
	id1 := t1.Id
	t1.Id = 0
	t1.Timestamp = now
	o.MustSave(t1)
	id2 := t1.Id
	_, err := o.One(Eq("Id", id1), &t1)
	if err != nil {
		t.Error(err)
	} else {
		if !t1.Timestamp.IsZero() {
			t.Errorf("expected zero timestamp, got %v instead", t1.Timestamp)
		}
	}
	_, err = o.One(Eq("Id", id2), t1)
	if err != nil {
		t.Error(err)
	} else {
		if !equalTimes(t1.Timestamp, now) {
			t.Errorf("invalid timestamp %v, expected %v.", t1.Timestamp, now)
		}
	}
}

func testSaveDelete(t *testing.T, o *Orm) {
	SaveTable := o.mustRegister((*Object)(nil), &Options{
		Table: "test_save",
	})
	o.mustInitialize()
	obj := &Object{Value: "Foo"}
	o.MustSave(obj)
	id1 := obj.Id
	// This should perform an insert, even when it has a primary key
	// because the update will have 0 rows affected.
	obj.Id = id1 + 1
	o.MustSave(obj)
	id2 := obj.Id
	count := o.Table(SaveTable).MustCount()
	if count != 2 {
		t.Errorf("expected count = 2, got %v instead", count)
	}
	// This should perform an update
	obj.Value = "Bar"
	o.MustSave(obj)
	count = o.Table(SaveTable).MustCount()
	if count != 2 {
		t.Errorf("expected count = 2, got %v instead", count)
	}
	var obj2 *Object
	_, err := o.One(Eq("Id", id2), &obj2)
	if err != nil {
		t.Error(err)
	} else if obj2 == nil {
		t.Error("obj2 is nil")
	} else if obj2.Value != obj.Value {
		t.Errorf("bad update, expected value %q, got %q instead", obj.Value, obj2.Value)
	}
	err = o.Delete(obj)
	if err != nil {
		t.Error(err)
	}
	count = o.Table(SaveTable).MustCount()
	if count != 1 {
		t.Errorf("expected count = 1, got %v instead", count)
	}
	res, err := o.DeleteFrom(SaveTable, Eq("Id", id1))
	if err != nil {
		t.Error(err)
	} else {
		aff, err := res.RowsAffected()
		if err != nil {
			t.Error(err)
		}
		if aff != 1 {
			t.Errorf("expected 1 affected rows by DELETE, got %v instead", aff)
		}
	}
	count = o.Table(SaveTable).MustCount()
	if count != 0 {
		t.Errorf("expected count = 0, got %v instead", count)
	}
}

func testData(t *testing.T, o *Orm) {
	o.mustRegister((*Data)(nil), &Options{
		Table: "test_data",
	})
	o.mustInitialize()
	data := []byte{1, 2, 3, 4, 5, 6}
	src := &Data{Data: data}
	o.MustSave(src)
	id := src.Id
	var d *Data
	_, err := o.One(Eq("Id", id), &d)
	if err != nil {
		t.Error(err)
	} else if d == nil {
		t.Error("d is nil")
	} else if !bytes.Equal(d.Data, data) {
		t.Errorf("invalid stored []byte. Want %v, got %v.", data, d.Data)
	}
}

func testInnerPointer(t *testing.T, o *Orm) {
	tags := o.Driver().Tags()
	if len(tags) == 1 && tags[0] == "datastore" {
		t.Log("skipping inner pointer test, datastore does not support them")
		return
	}
	o.mustRegister((*Outer)(nil), &Options{
		Table: "test_outer",
	})
	o.mustInitialize()
	out := Outer{Key: "foo"}
	if _, err := o.Save(&out); err != nil {
		t.Error(err)
	}
	out2 := Outer{Key: "bar", Inner: &Inner{A: 4, B: 2}}
	if _, err := o.Save(&out2); err != nil {
		t.Error(err)
	}
	var in Outer
	_, err := o.One(Eq("Key", "foo"), &in)
	if err != nil {
		t.Error(err)
	} else {
		if in.Inner != nil {
			t.Errorf("want %v, got %+v", nil, in.Inner)
		}
	}
	_, err = o.One(Eq("Key", "bar"), &in)
	if err != nil {
		t.Error(err)
	} else {
		if in.Inner != nil {
			if in.Inner.A != out2.Inner.A {
				t.Errorf("want %v, got %v", out2.Inner.A, in.Inner.A)
			}
			if in.Inner.B != out2.Inner.B {
				t.Errorf("want %v, got %v", out2.Inner.B, in.Inner.A)
			}
		} else {
			t.Errorf("want non-nil, got nil")
		}
	}
}

func testTransactions(t *testing.T, o *Orm) {
	if o.Driver().Capabilities()&driver.CAP_BEGIN == 0 {
		t.Log("skipping transaction begin/commit/rollback test")
		return
	}
	table := o.mustRegister((*AutoIncrement)(nil), &Options{
		Table: "test_transactions",
	})
	o.mustInitialize()
	obj := &AutoIncrement{}
	tx, err := o.Begin()
	if err != nil {
		t.Error(err)
		return
	}
	tx.MustSave(obj)
	tx.MustCommit()
	e, err := o.Exists(table, Eq("Id", obj.Id))
	if err != nil {
		t.Error(err)
	} else if !e {
		t.Error("commited object does not exist")
	}
	tx2 := o.MustBegin()
	obj.Id = 0
	tx2.MustSave(obj)
	tx2.MustRollback()
	e, err = o.Exists(table, Eq("Id", obj.Id))
	if err != nil {
		t.Error(err)
	} else if e {
		t.Error("rolled back object exists")
	}
}

func testFuncTransactions(t *testing.T, o *Orm) {
	if o.Driver().Capabilities()&driver.CAP_TRANSACTION == 0 {
		t.Log("skipping transaction func test")
		return
	}
	table := o.mustRegister((*AutoIncrement)(nil), &Options{
		Table: "test_transactions_func",
	})
	o.mustInitialize()
	obj := &AutoIncrement{}
	if err := o.Transaction(func(o *Orm) error {
		_, err := o.Save(obj)
		return err
	}); err != nil {
		t.Error(err)
	}
	e, err := o.Exists(table, Eq("Id", obj.Id))
	if err != nil {
		t.Error(err)
	} else if !e {
		t.Error("commited object does not exist")
	}
	if err := o.Transaction(func(o *Orm) error {
		obj.Id = 0
		o.MustSave(obj)
		return Rollback
	}); err != nil {
		t.Error(err)
	}
	e, err = o.Exists(table, Eq("Id", obj.Id))
	if err != nil {
		t.Error(err)
	} else if e {
		t.Error("rolled back object exists")
	}
}

func testCompositePrimaryKey(t *testing.T, o *Orm) {
	if o.Driver().Capabilities()&driver.CAP_COMPOSITE_PK == 0 {
		t.Log("skipping composite pk test")
		return
	}
	// This should fail with a duplicate PK error
	_, err := o.Register((*AutoIncrement)(nil), &Options{
		Table:      "test_composite_fail",
		PrimaryKey: []string{"non-existant"},
	})
	if err == nil {
		t.Error("expecting an error when registering duplicate PK")
	}
	// This should fail because the field can't be mapped
	_, err = o.Register((*Composite)(nil), &Options{
		Table:      "test_composite_fail",
		PrimaryKey: []string{"non-existant"},
	})
	if err == nil {
		t.Error("expecting an error when registering non-existant field as PK")
	}
	table := o.mustRegister((*Composite)(nil), &Options{
		Table:      "test_composite",
		PrimaryKey: []string{"Id", "Name"},
	})
	o.mustInitialize()
	comp := &Composite{
		Id:    1,
		Name:  "Foo",
		Value: "Bar",
	}
	o.MustSave(comp)
	c1, err := o.Count(table, nil)
	if err != nil {
		t.Error(err)
	}
	if c1 != 1 {
		t.Errorf("expecting 1 row, got %v instead", c1)
	}
	_, err = o.Insert(comp)
	if err == nil {
		t.Error("must return error because of duplicate constraint")
	}
	comp.Value = "Baz"
	o.MustSave(comp)
	var comp2 *Composite
	_, err = o.Table(table).Filter(Eq("Id", 1)).One(&comp2)
	if err != nil {
		t.Error(err)
	} else if comp2 == nil {
		t.Error("comp2 is nil")
	} else if comp2.Value != comp.Value {
		t.Errorf("value not updated. want %q, got %q", comp.Value, comp2.Value)
	}
	if comp2 == nil {
		comp2 = new(Composite)
	}
	comp2.Name = "Go!"
	if _, err := o.Save(comp2); err != nil {
		t.Error(err)
	}
	c2, err := o.Count(table, nil)
	if err != nil {
		t.Error(err)
	} else if c2 != 2 {
		t.Errorf("expecting 2 rows, got %v instead", c2)
	}
}

func testQueryAll(t *testing.T, o *Orm) {
	const count = 10
	_ = o.mustRegister((*AutoIncrement)(nil), &Options{
		Table: "test_query_all",
	})
	o.mustInitialize()
	obj := &AutoIncrement{}
	for ii := 0; ii < count; ii++ {
		obj.Id = 0
		o.MustInsert(obj)
	}
	var pobjects []*AutoIncrement
	err := o.All().Sort("Id", ASC).All(&pobjects)
	if err != nil {
		t.Error(err)
	}
	if len(pobjects) != count {
		t.Errorf("expecting %d objects, got %d instead", count, len(pobjects))
	}
	caps := o.Driver().Capabilities()
	autoId := caps&driver.CAP_AUTO_ID != 0
	autoIncrement := caps&driver.CAP_AUTO_INCREMENT != 0
	if autoId {
		if autoIncrement {
			for ii, v := range pobjects {
				exp := int64(ii + 1)
				if v.Id != exp {
					t.Errorf("expecting id %d at index %d, got %d instead", exp, ii, v.Id)
				}
			}
		} else {
			for ii := range pobjects {
				if ii > 0 {
					prev := pobjects[ii-1].Id
					cur := pobjects[ii].Id
					if prev >= cur {
						t.Errorf("id[%d] = %d >= id[%d] = %d", ii-1, prev, ii, cur)
					}
				}
			}
		}
	}

	var objects []AutoIncrement
	err = o.All().Sort("Id", DESC).All(&objects)
	if err != nil {
		t.Error(err)
	}
	if len(objects) != count {
		t.Errorf("expecting %d objects, got %d instead", count, len(objects))
	}
	if autoId {
		if autoIncrement {
			for ii, v := range objects {
				exp := int64(count - ii)
				if v.Id != exp {
					t.Errorf("expecting id %d at index %d, got %d instead", exp, ii, v.Id)
				}
			}
		} else {
			for ii := range objects {
				if ii > 0 {
					prev := objects[ii-1].Id
					cur := objects[ii].Id
					if prev <= cur {
						t.Errorf("id[%d] = %d <= id[%d] = %d", ii-1, prev, ii, cur)
					}
				}
			}
		}
	}
}

func testDefaults(t *testing.T, o *Orm) {
	o.mustRegister((*EmptyDefaulter)(nil), &Options{
		Table: "test_empty_defaults",
	})
	o.mustRegister((*PartialDefaulter)(nil), &Options{
		Table: "test_partial_defaults",
	})
	o.mustRegister((*Defaulter)(nil), &Options{
		Table: "test_defaults",
	})
	o.mustInitialize()
	edef := EmptyDefaulter{}
	o.MustSave(edef)
	found, err := o.One(nil, &edef)
	if err != nil {
		t.Error(err)
	} else if !found {
		t.Error("not found")
	} else {
		if edef.Val1 != "Gondola" {
			t.Errorf("expecting val1 = Gondola, got %v", edef.Val1)
		}
		if edef.Val2 != 7 {
			t.Errorf("expecting val2 = 7, got %v", edef.Val2)
		}
	}
	pdef := PartialDefaulter{Val1: "Gondola"}
	o.MustSave(pdef)
	found, err = o.One(nil, &pdef)
	if err != nil {
		t.Error(err)
	} else if !found {
		t.Error("not found")
	} else {
		if pdef.Val1 != "Gondola" {
			t.Errorf("expecting val1 = Gondola, got %v", pdef.Val1)
		}
		if pdef.Val2 != "Gondola" {
			t.Errorf("expecting val2 = Gondola, got %v", pdef.Val2)
		}
	}
	def := &Defaulter{}
	o.MustSave(def)
	found, err = o.One(Eq("Id", def.Id), def)
	if err != nil {
		t.Error(err)
	} else if !found {
		t.Error("not found")
	} else {
		if def.Val1 != "Gondola" {
			t.Errorf("expecting val1 = Gondola, got %v", def.Val1)
		}
		if def.Val2.IsZero() {
			t.Error("expecting val3 non-zero time")
		} else {
			now := time.Now().UTC()
			begin := now.Add(-time.Second)
			end := now.Add(time.Second)
			if def.Val2.Before(begin) || end.Before(def.Val2) {
				t.Errorf("returned time %s out of expected bounds %s and %s", def.Val2, begin, end)
			}
		}
		today := funcToday()
		if !def.Val3.Equal(today) {
			t.Errorf("expecting today() value %s, got %s instead", today, def.Val3)
		}
	}
}

func testSaveUnchanged(t *testing.T, o *Orm) {
	o.mustRegister((*AutoIncrement)(nil), nil)
	o.mustInitialize()
	obj := &AutoIncrement{Id: 12345, Value: "gondola"}
	if _, err := o.Save(obj); err != nil {
		t.Error(err)
	}
	// Second save should do an UPDATE, not an INSERT
	// even if the data hasn't changed.
	if _, err := o.Save(obj); err != nil {
		t.Error(err)
	}
}

func testQueryTransform(t *testing.T, o *Orm) {
	o.mustRegister((*Timestamped)(nil), nil)
	o.mustInitialize()
	ts := time.Now()
	obj := &Timestamped{
		Timestamp: ts,
	}
	if _, err := o.Save(obj); err != nil {
		t.Error(err)
		return
	}
	typ := reflect.TypeOf(obj)
	tbl := o.TypeTable(typ)
	// Try to retrieve the item with an eq query
	c, err := o.Table(tbl).Filter(Eq("Timestamp", ts)).Count()
	if err != nil {
		t.Error(err)
	} else if c != 1 {
		t.Errorf("expecting 1 object, got %v", c)
	}
	// Try to retrieve the item with a between query
	c, err = o.Table(tbl).Filter(Between("Timestamp", ts.Add(-time.Second), ts.Add(time.Second))).Count()
	if err != nil {
		t.Error(err)
	} else if c != 1 {
		t.Errorf("expecting 1 object, got %v", c)
	}

}

func runAllTests(t *testing.T, o opener) {
	orm, data := o.Open(t)
	defer o.Close(data)
	defer orm.Close()
	testOrm(t, orm, o.Name())
}

func testOrm(t *testing.T, o *Orm, name string) {
	tests := []func(*testing.T, *Orm){
		testCodecs,
		testAutoIncrement,
		testTime,
		testSaveDelete,
		testLoadSaveMethods,
		testLoadSaveMethodsErrors,
		testData,
		testInnerPointer,
		testTransactions,
		testFuncTransactions,
		testCompositePrimaryKey,
		testReferences,
		testQueryAll,
		testDefaults,
		testMigrations,
		testSaveUnchanged,
		testQueryTransform,
	}
	for _, v := range tests {
		t.Run(testName(name, v), func(t *testing.T) {
			clearRegistry(o)
			v(t, o)
		})
	}
}
